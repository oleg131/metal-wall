{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["CORS_HOST","process","Main","Home","useState","items","setItems","start","setStart","hasMore","sethasMore","processData","data","date","match","el0","document","createElement","innerHTML","artist","getElementsByTagName","innerText","el1","album","url","getAttribute","id","split","pop","cover","fetchData","displayStart","today","moment","month","year","fromMonth","toYear","toMonth","replace","console","log","fetch","then","res","json","aaData","length","map","filter","a","format","sort","b","reverse","concat","iTotalRecords","useEffect","role","className","dataLength","next","loader","endMessage","item","index","Album","key","setClassName","href","target","rel","src","fallbackImage","Empty","onLoad","App","Boolean","window","location","hostname","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.69c6ce58.chunk.js","sourcesContent":["import React, { Fragment, useState, useEffect } from 'react';\nimport { BrowserRouter, Switch, Route } from 'react-router-dom';\nimport InfiniteScroll from 'react-infinite-scroll-component';\nimport ReactImageFallback from \"react-image-fallback\";\nimport moment from 'moment';\n\nimport './App.css';\n\nconst CORS_HOST = process.env.REACT_APP_CORS_HOST || 'http://localhost:8080/'\n\nfunction App() {\n  return (\n    <div>\n      {/* <Header /> */}\n      <Main />\n    </div>\n  );\n}\n\nfunction Header() {\n  return (\n    <div className=\"text-center\">\n      <h2 style={{'font-family': 'Georgia'}}>\n        Latest metal releases\n      </h2>\n    </div>\n  )\n}\n\nfunction Main() {\n  return (\n    <Home />\n  );\n}\n\nfunction Home() {\n  const [items, setItems] = useState([]);\n  const [start, setStart] = useState(null);\n  const [hasMore, sethasMore] = useState(true);\n  \n  useEffect(() => {\n    fetchData(start);\n  }, [])\n\n  function processData(data) {\n    const m = data[2].match('<!-- (.+) -->');\n    const date = m[1];\n\n    const el0 = document.createElement('html');\n    el0.innerHTML = data[0];\n    const artist = el0.getElementsByTagName('a')[0].innerText;\n\n    const el1 = document.createElement('html');\n    el1.innerHTML = data[1];\n    const album = el1.getElementsByTagName('a')[0].innerText;\n\n    const as = el1.getElementsByTagName('a');\n    const url = as[0].getAttribute('href');\n    const id = url.split('/').pop();\n    const cover = `https://www.metal-archives.com/images/${id[0]}/${id[1]}/${id[2]}/${id[3]}/${id}.`\n\n    return {\n      url, id, cover, date, artist, album\n    }\n  }\n\n  function fetchData(displayStart) {\n    const today = moment();\n\n    const month = today.month() + 1;\n    const year = today.year();\n\n    const [fromYear, fromMonth, toYear, toMonth] = [year - 1, month, year, month];\n\n    const url = CORS_HOST + `https://www.metal-archives.com/search\n    /ajax-advanced/searching/albums/?bandName=&releaseTitle=\n    &releaseYearFrom=${fromYear}&releaseMonthFrom=${fromMonth}\n    &releaseYearTo=${toYear}&releaseMonthTo=${toMonth}\n    &country=&location=&releaseLabelName=&releaseCatalogNumber=&releaseIdentifiers=\n    &releaseRecordingInfo=&releaseDescription=&releaseNotes=&genre=&releaseType[]=1\n    &sEcho=1&iColumns=3&sColumns=&iDisplayStart=DISPLAYSTART\n    &iDisplayLength=200`.replace(/\\n/g, '').replace(/ /g, '')\n\n    if (!displayStart) {\n      console.log('fetch initial')\n\n      fetch(url.replace('DISPLAYSTART', 0))\n        .then(res => res.json())\n        .then(function(data) {\n          fetchData(data.iTotalRecords - 200)\n        })\n    } else {\n      console.log('fetch with start', displayStart)\n\n      fetch(url.replace('DISPLAYSTART', displayStart))\n        .then(res => res.json())\n        .then(function(data) {\n          setStart(displayStart - 200);\n\n          if (data.aaData.length === 0) {\n            sethasMore(false);\n            return\n          }\n\n          data = data.aaData.map(processData);\n          data = data.filter(a => a.date <= moment().format(\"YYYY-MM-DD\"));\n          data.sort((a, b) => a.date < b.date).reverse();\n          setItems(items.concat(data)); \n          console.log('fetched', data.length)\n        })\n    }\n  }\n\n  return (\n    <main role=\"main\" className=\"container-fluid text-center\">      \n      <InfiniteScroll\n        dataLength={ items.length } //This is important field to render the next data\n        next={ () => fetchData(start) }\n        hasMore={ hasMore }\n        loader=\"Loading\"\n        endMessage=\"The end\"\n      >\n          <div className=\"text-center\">\n            {\n              items.map(\n                (item, index) => (\n                  <Album data={item} key={index} />\n                )\n              )\n            }\n          </div>\n\n      </InfiniteScroll>\n    </main>\n  );\n}\n\nfunction Album({ data }) {\n\n  const [className, setClassName] = useState(\"thumbnail zoom\");\n  \n  return (\n    <div className={className}>\n      <a \n        href={\"https://www.youtube.com/results?search_query=\" + data.artist + \" \" + data.album} \n        target=\"_blank\" rel=\"noopener noreferrer\">\n        <ReactImageFallback\n          src={data.cover + 'jpg'}\n          fallbackImage={[\n            data.cover + 'jpeg', \n            <Empty onLoad={ () => setClassName(className + ' empty-thumbnail') } />\n          ]}\n          className=\"thumbnail-image\"\n        />\n      </a>\n    </div>\n  )\n}\n\nfunction Empty({ onLoad }) {\n  useEffect(() => onLoad())\n  return (\n    <Fragment />\n  )\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport 'bootstrap/dist/css/bootstrap.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}